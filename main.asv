function main()
    clear control
    clear static_counter
    cvx_clear
    clear all
    params = config();
    

    [path] = bezier_path(params.ctrl_pts, params.num_path_pts);

    
    q = [0.050, 0.1];            % 初始位置(mm)
    psi0 = 0;           % 初始朝向(rad)
    v_c = 0.141;               % 初始速度大小(mm/s)
    vx = 0.1;
    vy = 0.1;
    omega_b = 0.001;
    
    q_history = zeros(params.num_steps, 2);
    vi_history = zeros(params.num_steps, 4);
    phidot_history = zeros(params.num_steps, 4);
    vc_history = zeros(params.num_steps, 1);
    t_history = zeros(params.num_steps, 1);
    phi_history=zeros(params.num_steps,4);
    
    state_dot=[vx ; vy ; omega_b];
0
    %仿真循环0
    for k = 1:pbarams.num_steps
        t = (k-1)*params.dt;
        t_history(k) = t;
        q_history(k,:) = q;
        vc_history(k) = psi0;
        state = [q , psi0];
       
        if((path(1,end)-q(1))^2+(path(2,end)-q(2))^2>0.001)    
        [new_state_dot] = control_RSS(path,k,state_dot,state);
        % 更新状态
        end
        vx = new_state_dot(1);
        vy = new_state_dot(2);
        v_c = sqrt(vx^2+vy^2);
        psiv = atan2(vy,vx);
        omega_b= new_state_dot(3);
          phi = [0;0;0;0];
        vi = [0;0;0;0];
        cos_theta = cos(psi0);
        sin_theta = sin(psi0);
      
        for i = 1:4
        Hj = [1,0,-params.wheel_pos(i,2);0,1,params.wheel_pos(i,1)];
        zn = Hj * [cos_theta,sin_theta,0;-sin_theta,cos_theta,0;0,0,1] * new_state_dot;
        vxi = zn(1);
        vyi = zn(2);
        vi(i) = sqrt(vxi^2+vyi^2);
        phi(i) = atan2(vyi,vxi);
        end

        vi_history(k,:) = vi;
        phi_history(k,:) = phi;


        psi0 = psi0 + omega_b * params.dt;
        q = q + [vx , vy]* params.dt;
        state_dot = new_state_dot;
    
      
        
        
        
    end
    phidot_history = diff(phi_history);
    % 角度归一化：将phidot_history每个元素限制在(-π, π]区间（更通用的写法）
for m = 1:params.num_steps
    % 先取第m个元素（避免重复索引）
    phi_val = phidot_history(m);
    
    % 方法1：用mod函数直接归一化（MATLAB内置函数，最简洁）
    phi_val = mod(phi_val + pi, 2*pi) - pi;
    
    % 方法2：手动归一化（替代while，避免死循环）
    % while phi_val > pi
    %     phi_val = phi_val - 2*pi;
    % end
    % while phi_val < -pi
    %     phi_val = phi_val + 2*pi;
    % end
    
    % 将归一化后的值写回数组
    phidot_history(m) = phi_val;
end
    
    plot_results(q_history, vi_history, [[0,0,0,0];phidot_history], vc_history, t_history, path);
    
end

