function [new_state_dot] = control_RSS(path, k, state_dot, state)
    
    params = config();
   
    % ================= Param Setup =================
    psi0=state(3);
    K = 5;                     % 预测时域 (Prediction Horizon)
    dt = params.dt;
    rho = 0.01;                  % 正则化权重 (Regularization weight)
    alpha = zeros(3,K);
    k1=0.1;
    % 提取当前状态
    current_xy = [state(1),state(2)]'; % [x; y]全局速度
  

    current_theta = state(3);   % theta
    current_nu = [cos(psi0),sin(psi0),0;-sin(psi0),cos(psi0),0;0,0,1]*state_dot;     % [vx; vy; omega] (Body Frame)
    
    % Wheel_i_vel = H{i} * nu
    
    H = cell(1, 4);
    for i = 1:4
       
        H{i} = [1, 0, -params.wheel_pos(i,2); 0, 1, params.wheel_pos(i,1)];
    end
    
    max_iter = 3; 
    u_current=zeros(3,K);
    J_prev=0;
    for i = 1 : max_iter
    u_prev=alpha;
   
    cvx_solver ECOS; % 或者用 OSQP/ECOS，对于MPC通常比SCS更快
      cvx_begin 
      
            variable u(3, K) % 控制增量 [ax; ay; alpha] * dt
            variable nu(3, K+1)
            variable NU(3, K+1)
            variable sumomega(1,K+1)
            % 定义状态序列 nu (机体速度)
            
           
            expression J
            expression summ1(K,4)
            expression summ2(K,4)
           
            
            R_psi0 =[cos(psi0),-sin(psi0);sin(psi0),cos(psi0)];
            S=[1,0,0;0,1,0];
            C_1=R_psi0 * S .*dt;
            
           
            for t = 2:K
                NU=0;
                sumomega=0;
                for l = 1:t
                NU=nu(:,l)+NU; 
                sumomega=sumomega+nu(3,l);
                end
               J = J + sum_square(current_xy - path(1:2,min(params.num_steps, t+k-1)) + C_1 * NU(:,l)) + k1 * sum_square(psi0 + sumomega * dt - path(3, min(params.num_steps, t+k-1)));
            end
  
            %path(1:2,min(params.num_steps,t+k))

           minimize(J + 0.01 * sum_square(u(:)) + rho * sum_square(u(:) - u_prev(:)));
          
         %{            
           for j=1:4
               0.5*norm(H{j}*u(:,k))^2
            end
         %}
        
     
       
        R=[cos(params.phidotmax*dt),-sin(params.phidotmax*dt);sin(params.phidotmax*dt),cos(params.phidotmax*dt)];
        u_cumsum = [zeros(3, 1), cumsum(alpha(:, 1:K-1), 2)]; 
        nu_hat= repmat(current_nu, 1, K) + u_cumsum;
        subject to
            nu(:, 1) == current_nu;
            for t = 1:K-1
                nu(:, t+1) == nu(:, t) + u(:, t);
            end
            for s=1:K
                v=zeros(K,1);
                v(1:s)=1;
            NU(:,s)==nu*v;
            sumom
            end
          for l=1:K
              
            for ii=1:4
                summ1(l,ii)=0;
                summ2(l,ii)=0;
              for jj=1:l-1
                 summ1(l,ii) =summ1(l,ii)+( (eye(2) + R ) * H{ii} * nu_hat(:,l) + R * H{ii} * alpha(:,l) )' * (eye(2) + R ) * H{ii} * ( u(:,jj) - alpha(:,jj) );
                 summ2 (l,ii)=summ2(l,ii)+( (eye(2) + R') * H{ii} * nu_hat(:,l) + R'* H{ii} * alpha(:,l) )' * (eye(2) + R') * H{ii} * ( u(:,jj) - alpha(:,jj) );
              end 
          
          % 0.5 * sum_square((H{ii} * nu(:,l)) ) + 0.5 * sum_square((H{ii} * (nu(:,l) + u(:,l)) ))...
          % -(0.5 * sum_square( ( ( eye(2) + R ) * H{ii} * nu_hat(:,l) + R * H{ii} * alpha(:,l)) )+(( eye(2) + R ) * H{ii} * nu_hat(:,l) + R * H{ii} * alpha(:,l))'...
          % * R * H{ii} * ( u(:,l) - alpha(:,l)) + summ1(l, ii)) <= 0;

          % % 0.5 * sum_square( H{ii} * nu(:,l) )  + 0.5 * sum_square((H{ii} * (nu(:,l) + u(:,l))))...
          % % -(0.5 * sum_square( ( eye(2) + R') * H{ii} * nu_hat(:,l) + R' * H{ii} * alpha(:,l) )+(( eye(2) + R') * H{ii} * nu_hat(:,l) + R'* H{ii} * alpha(:,l))'...
          % % * R'* H{ii} * ( u(:,l) - alpha(:,l)) + summ2(l, ii)) <= 0;

              norm(H{ii} * nu(:,l), 2) <= params.vimax;
            end
          end
        
      %}
          cvx_end
          fprintf('最优代价是: %f\n', cvx_optval);
        if strcmp(cvx_status, 'Solved') || strcmp(cvx_status, 'Failed')
            
           fprintf('正在执行，已经进行第%d步/%d\n', k , i );
        else
            % 如果求解失败，使用上一时刻的解或全零
            % disp(['Optimization failed at step ', num2str(k), ': ', cvx_status]);
        end
       
      % if(abs(J_prev-cvx_optval)<1)
      %      break
      %  end
     %     J_prev=cvx_optval;
     if(norm(u-alpha))
     end
       if any(isnan(u(:)))
    u = alpha; 
   
       end

       alpha = u;
    end
    % 输出下一步的状态导数 (即下一步的速度)
    % nu^{k+1} = nu^k + u^k
    new_state_dot = [cos(state(3)),-sin(state(3)),0;sin(state(3)),cos(state(3)),0;0,0,1]*(current_nu + u(:, 1));
end
